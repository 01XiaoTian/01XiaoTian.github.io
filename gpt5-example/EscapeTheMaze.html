<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Escape the Maze</title>
  <style>
    :root {
      --bg: #0f1220;
      --panel: #151a2e;
      --accent: #6ee7ff;
      --accent-2: #7cffb6;
      --danger: #ff6b6b;
      --text: #e6e8ef;
      --muted: #a7b0c0;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: radial-gradient(1200px 800px at 30% -10%, #1a2140 0%, var(--bg) 60%);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      display: grid;
      place-items: center;
    }
    .wrap {
      width: min(92vw, 980px);
      display: grid;
      grid-template-columns: 1fr 320px;
      gap: 16px;
      align-items: start;
    }
    @media (max-width: 900px) {
      .wrap { grid-template-columns: 1fr; }
    }
    .card {
      background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.35);
      overflow: hidden;
    }
    .board {
      padding: 14px;
    }
    #mazeCanvas {
      width: 100%;
      height: auto;
      display: block;
      background: #0a0d1a;
      border-radius: 10px;
    }
    .panel {
      padding: 16px 18px 18px;
      display: grid;
      gap: 14px;
    }
    .title {
      font-size: 1.25rem;
      font-weight: 700;
      letter-spacing: .3px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .title .dot { width: 10px; height: 10px; border-radius: 999px; background: var(--accent); box-shadow: 0 0 14px var(--accent); }
    .stats {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
    }
    .stat {
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      padding: 12px;
    }
    .stat .label { color: var(--muted); font-size: .78rem; letter-spacing: .2px; }
    .stat .value { font-size: 1.1rem; font-weight: 700; margin-top: 4px; }

    .controls { display: grid; gap: 10px; }
    .row { display: flex; gap: 10px; }
    button {
      all: unset;
      cursor: pointer;
      background: linear-gradient(180deg, #1f2a44, #162038);
      border: 1px solid rgba(255,255,255,0.1);
      padding: 10px 12px;
      border-radius: 10px;
      text-align: center;
      font-weight: 600;
      transition: transform .05s ease, filter .15s ease;
      user-select: none;
    }
    button:hover { filter: brightness(1.05); }
    button:active { transform: translateY(1px) scale(0.99); }
    .primary { background: linear-gradient(180deg, #2a7fff, #1e5cff); border-color: rgba(0,0,0,0.25); color: white; }
    .ghost { background: rgba(255,255,255,0.04); }
    .hint { color: var(--accent-2); }

    .kbd {
      display: inline-grid;
      place-items: center;
      width: 28px; height: 28px;
      border-radius: 6px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.08);
      font-weight: 700;
      margin-right: 6px;
    }
    .notes { font-size: .9rem; color: var(--muted); line-height: 1.45; }
    .success { color: var(--accent-2); font-weight: 700; }
    .danger { color: var(--danger); font-weight: 700; }
    .hidden { display: none; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card board">
      <canvas id="mazeCanvas" width="720" height="720" aria-label="Escape the Maze game area"></canvas>
    </div>
    <aside class="card panel" role="complementary">
      <div class="title"><span class="dot"></span>Escape the Maze</div>
      <div class="stats">
        <div class="stat"><div class="label">Timer</div><div class="value" id="timer">0.00 s</div></div>
        <div class="stat"><div class="label">Steps</div><div class="value" id="steps">0</div></div>
        <div class="stat"><div class="label">Shortest Path</div><div class="value" id="shortest">–</div></div>
        <div class="stat"><div class="label">Best Time</div><div class="value" id="best">–</div></div>
      </div>
      <div class="controls">
        <div class="row">
          <button class="primary" id="replayBtn" title="Generate a new maze (R)">↻ Replay</button>
          <button class="ghost hint" id="toggleHintBtn" title="Show/Hide shortest path (H)">★ Hint</button>
        </div>
        <div class="notes">
          Move with <span class="kbd">↑</span><span class="kbd">↓</span><span class="kbd">←</span><span class="kbd">→</span> (or WASD). Reach the red goal square.
          Finish with the <b>shortest possible steps</b> to earn a <span class="success">bonus</span>.
        </div>
        <div class="notes" id="message"></div>
      </div>
    </aside>
  </div>

  <script>
    // ====== Config ======
    const CFG = {
      cols: 23,                  // number of columns in the maze grid
      rows: 23,                  // number of rows in the maze grid
      wallColor: '#6ee7ff',      // maze wall color
      wallWidth: 2.2,            // maze wall stroke width (px)
      floorColor: '#0a0d1a',     // canvas background / floor color
      startColor: '#1ee89a',     // start cell color (green)
      goalColor: '#ff6b6b',      // goal cell color (red)
      avatarColor: '#ffe066',    // player color
      stepBonus: 500,            // bonus points for shortest path
    };

    // ====== DOM ======
    const canvas = document.getElementById('mazeCanvas');
    const ctx = canvas.getContext('2d');
    const timerEl = document.getElementById('timer');
    const stepsEl = document.getElementById('steps');
    const shortestEl = document.getElementById('shortest');
    const bestEl = document.getElementById('best');
    const replayBtn = document.getElementById('replayBtn');
    const toggleHintBtn = document.getElementById('toggleHintBtn');
    const messageEl = document.getElementById('message');

    // Responsive canvas sizing (square)
    function fitCanvas() {
      const board = canvas.parentElement.getBoundingClientRect();
      const size = Math.min(board.width, window.innerHeight * 0.8);
      const rounded = Math.max(420, Math.min(820, Math.floor(size)));
      canvas.style.width = rounded + 'px';
      canvas.style.height = rounded + 'px';
      // Keep internal resolution crisp on HiDPI screens
      const scale = window.devicePixelRatio || 1;
      canvas.width = Math.floor(rounded * scale);
      canvas.height = Math.floor(rounded * scale);
      ctx.setTransform(scale, 0, 0, scale, 0, 0);
      draw();
    }
    window.addEventListener('resize', fitCanvas);

    // ====== Maze Data Structures ======
    class Cell {
      constructor(x, y) {
        this.x = x; this.y = y;
        this.walls = { top: true, right: true, bottom: true, left: true };
        this.visited = false;
      }
    }

    let grid, player, goal, cellSize, margin;
    let shortestSteps = null, shortestPath = [];
    let steps = 0;
    let startTime = 0, elapsed = 0, timerId = null;
    let gameOver = false;
    let showHint = false;

    const DIRS = [
      { dx: 0, dy: -1, wall: 'top', opp: 'bottom' },
      { dx: 1, dy: 0, wall: 'right', opp: 'left' },
      { dx: 0, dy: 1, wall: 'bottom', opp: 'top' },
      { dx: -1, dy: 0, wall: 'left', opp: 'right' },
    ];

    function idx(x, y) { return y * CFG.cols + x; }

    function buildGrid() {
      grid = new Array(CFG.cols * CFG.rows).fill(null).map((_, i) => new Cell(i % CFG.cols, Math.floor(i / CFG.cols)));
    }

    function neighbors(cell) {
      const res = [];
      for (const d of DIRS) {
        const nx = cell.x + d.dx, ny = cell.y + d.dy;
        if (nx >= 0 && nx < CFG.cols && ny >= 0 && ny < CFG.rows) {
          res.push({ cell: grid[idx(nx, ny)], dir: d });
        }
      }
      return res;
    }

    // Recursive backtracker: perfect maze (no loops, single path between any two cells)
    function carveMaze() {
      const stack = [];
      const start = grid[0];
      start.visited = true;
      stack.push(start);
      while (stack.length) {
        const current = stack[stack.length - 1];
        const unvisited = neighbors(current).filter(n => !n.cell.visited);
        if (unvisited.length === 0) { stack.pop(); continue; }
        const pick = unvisited[Math.floor(Math.random() * unvisited.length)];
        // remove walls between current and picked neighbor
        current.walls[pick.dir.wall] = false;
        pick.cell.walls[pick.dir.opp] = false;
        pick.cell.visited = true;
        stack.push(pick.cell);
      }
    }

    // BFS for shortest path and length (in steps)
    function bfsShortest(startX, startY, endX, endY) {
      const q = [];
      const seen = new Set();
      const parent = new Map(); // key: "x,y" => previous key
      const key = (x, y) => `${x},${y}`;
      q.push({ x: startX, y: startY });
      seen.add(key(startX, startY));
      while (q.length) {
        const { x, y } = q.shift();
        if (x === endX && y === endY) {
          // reconstruct path
          const path = [];
          let cur = key(x, y);
          while (cur) { path.push(cur); cur = parent.get(cur); }
          path.reverse();
          return { length: path.length - 1, path: path.map(s => s.split(',').map(Number)) };
        }
        const c = grid[idx(x, y)];
        DIRS.forEach(d => {
          if (!c.walls[d.wall]) {
            const nx = x + d.dx, ny = y + d.dy;
            const k = key(nx, ny);
            if (!seen.has(k)) { seen.add(k); parent.set(k, key(x, y)); q.push({ x: nx, y: ny }); }
          }
        });
      }
      return { length: Infinity, path: [] };
    }

    // ====== Rendering ======
    function drawMaze() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = CFG.floorColor; // reset background
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // cellSize derived from canvas
      cellSize = Math.floor((canvas.clientWidth - 24) / CFG.cols);
      margin = Math.floor((canvas.clientWidth - cellSize * CFG.cols) / 2);

      // Draw start and goal cells
      const drawCellFill = (x, y, color) => {
        ctx.fillStyle = color;
        ctx.fillRect(margin + x * cellSize + 3, margin + y * cellSize + 3, cellSize - 6, cellSize - 6);
      };
      drawCellFill(0, 0, CFG.startColor);
      drawCellFill(CFG.cols - 1, CFG.rows - 1, CFG.goalColor);

      // Maze walls
      ctx.strokeStyle = CFG.wallColor;
      ctx.lineWidth = CFG.wallWidth;
      ctx.lineCap = 'square';
      for (let y = 0; y < CFG.rows; y++) {
        for (let x = 0; x < CFG.cols; x++) {
          const c = grid[idx(x, y)];
          const x0 = margin + x * cellSize;
          const y0 = margin + y * cellSize;
          ctx.beginPath();
          if (c.walls.top)    { ctx.moveTo(x0, y0); ctx.lineTo(x0 + cellSize, y0); }
          if (c.walls.right)  { ctx.moveTo(x0 + cellSize, y0); ctx.lineTo(x0 + cellSize, y0 + cellSize); }
          if (c.walls.bottom) { ctx.moveTo(x0, y0 + cellSize); ctx.lineTo(x0 + cellSize, y0 + cellSize); }
          if (c.walls.left)   { ctx.moveTo(x0, y0); ctx.lineTo(x0, y0 + cellSize); }
          ctx.stroke();
        }
      }

      // Hint path (optional)
      if (showHint && shortestPath.length) {
        ctx.lineWidth = Math.max(2, Math.floor(cellSize * 0.2));
        ctx.strokeStyle = 'rgba(124,255,182,0.5)';
        ctx.lineJoin = 'round';
        ctx.beginPath();
        for (let i = 0; i < shortestPath.length; i++) {
          const [cx, cy] = shortestPath[i];
          const cxPix = margin + cx * cellSize + cellSize / 2;
          const cyPix = margin + cy * cellSize + cellSize / 2;
          if (i === 0) ctx.moveTo(cxPix, cyPix); else ctx.lineTo(cxPix, cyPix);
        }
        ctx.stroke();
      }
    }

    function drawPlayer() {
      const x = margin + player.x * cellSize + cellSize / 2;
      const y = margin + player.y * cellSize + cellSize / 2;
      const r = Math.max(6, Math.floor(cellSize * 0.32));
      // glow ring
      ctx.fillStyle = 'rgba(255,224,102,0.18)';
      ctx.beginPath(); ctx.arc(x, y, r + 8, 0, Math.PI * 2); ctx.fill();
      // body
      ctx.fillStyle = CFG.avatarColor;
      ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();
    }

    function draw() {
      if (!grid) return;
      drawMaze();
      drawPlayer();
    }

    // ====== Game Loop / Timer ======
    function startTimer() {
      startTime = performance.now();
      if (timerId) cancelAnimationFrame(timerId);
      const tick = () => {
        if (!gameOver) {
          elapsed = (performance.now() - startTime) / 1000;
          timerEl.textContent = `${elapsed.toFixed(2)} s`;
          timerId = requestAnimationFrame(tick);
        }
      };
      tick();
    }

    function stopTimer() {
      gameOver = true;
      if (timerId) cancelAnimationFrame(timerId);
    }

    // ====== Controls ======
    function canMove(px, py, dir) {
      const c = grid[idx(px, py)];
      return !c.walls[dir.wall];
    }

    function move(dx, dy, wallName) {
      if (gameOver) return;
      const dir = DIRS.find(d => d.dx === dx && d.dy === dy);
      if (!dir) return;
      if (canMove(player.x, player.y, dir)) {
        player.x += dx; player.y += dy; steps++; stepsEl.textContent = steps;
        draw();
        if (player.x === goal.x && player.y === goal.y) finish();
      }
    }

    function finish() {
      stopTimer();
      const timeScore = Math.max(0, Math.round(1000 - elapsed * 50));
      const bonus = (steps === shortestSteps) ? CFG.stepBonus : 0;
      const score = timeScore + bonus;
      const msg = `Escaped in ${elapsed.toFixed(2)} s · ${steps} steps. ` + (bonus ? `Shortest path! Bonus +${CFG.stepBonus}.` : `Shortest is ${shortestSteps}.`);
      messageEl.innerHTML = `<span class="success">${msg}</span><br>Score: <b>${score}</b>`;
      // best time (smaller is better)
      const best = parseFloat(localStorage.getItem('etm_best_time') || '0');
      if (!best || elapsed < best) {
        localStorage.setItem('etm_best_time', String(elapsed));
      }
      const bestTime = parseFloat(localStorage.getItem('etm_best_time'));
      bestEl.textContent = bestTime ? `${bestTime.toFixed(2)} s` : '–';
    }

    function keyHandler(e) {
      const k = e.key.toLowerCase();
      if (["arrowup","arrowdown","arrowleft","arrowright"," ","space"].includes(e.key.toLowerCase())) e.preventDefault();
      if (k === 'arrowup' || k === 'w') move(0, -1);
      else if (k === 'arrowdown' || k === 's') move(0, 1);
      else if (k === 'arrowleft' || k === 'a') move(-1, 0);
      else if (k === 'arrowright' || k === 'd') move(1, 0);
      else if (k === 'r') initGame();
      else if (k === 'h') { showHint = !showHint; draw(); }
    }
    window.addEventListener('keydown', keyHandler, { passive: false });

    // ====== Game Setup ======
    function initGame() {
      messageEl.textContent = '';
      steps = 0; stepsEl.textContent = '0';
      gameOver = false; showHint = false;
      buildGrid();
      carveMaze();
      player = { x: 0, y: 0 };
      goal = { x: CFG.cols - 1, y: CFG.rows - 1 };
      const sp = bfsShortest(player.x, player.y, goal.x, goal.y);
      shortestSteps = sp.length; shortestPath = sp.path;
      shortestEl.textContent = shortestSteps;
      const bestTime = parseFloat(localStorage.getItem('etm_best_time'));
      bestEl.textContent = bestTime ? `${bestTime.toFixed(2)} s` : '–';
      fitCanvas();
      startTimer();
    }

    replayBtn.addEventListener('click', initGame);
    toggleHintBtn.addEventListener('click', () => { showHint = !showHint; draw(); });

    // Kick off
    initGame();
  </script>
</body>
</html>
